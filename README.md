## POLKA SageMath implementation

This repository contains the reference implementation of the [POLKA](https://eprint.iacr.org/2022/873) scheme. The implementation is done in python taking advantage of the features offered by the SageMath tool suite. While the original specifications of the scheme do not require the use of a specific hash function or for the AE scheme, the presented implementation relies on the ASCON family, recently selected by the NIST as the new standard for lightweight symmetric cryptography. 

## Dependencies 

* [SageMath](https://www.sagemath.org/) (SageMath version 9.5, Release Date: 2022-01-30 version has been tested)
* Python (Python 3.10.6 has been tested)
* Numpy package (numpy==1.23.3 has been tested)
* ASCON AE/Hash implementation (implemented as a submodule of [pyascon](https://github.com/meichlseder/pyascon)
* GNU Make (v4.2.1 Built for x86_64-pc-linux-gnu tested)
* bash on Unix system (GNU bash, version 5.0.17(1)-release (x86_64-pc-linux-gnu) on Ubuntu 20.04.3 tested)

## Installation 

The POLKA scheme is implemented by the files [polka.sage](polka.sage) and [polka_utils.sage](polka_utils.sage). In order to be easily imported in 
a broader project, these can be preparsed by running the script [preparse.sh](preparse.sh) with the following command

```bash
make clean
make
```

This script simply use the sage utility with the `-preparse` flag in order to generate the `.py` from the `.sage` files. Once done, it allows any user to directly use the function implemented in a classical Python fashion using the `import` keyword. 

The [pyascon](https://github.com/meichlseder/pyascon) should also be initialized, which can be done with the following commands
```
git submodule init 
git submodule update
```

## API
The file [polka_utils.sage](polka_utils.sage) contains some class and functions required for the implementation of the scheme. Namely, it defines the classes Params and PRNG. The first one is used to create the parameter set of the considered instance(s) in a generic manner while the second one is used to instanciate the PRNG producing the randomness at the different stages of the scheme (more details can be found at the end of the Section and in the file [polka_utils.sage](polka_utils.sage)).

The file [polka.sage](polka.sage) contains the following top-level functions:
* `keygen(prng, version="16")`:  Implements the generation of the key pair. Takes as input the PRNG instance `prng`.  The version is by default set to "16" (for 16-bits) and is kept for future developpement. 
* `encrypt(prng, pk, M, nonce)`: Implements the encryption process of POLKA. The practical implementation relies on the ASCON hash function to generate the value of `K` and on the ASCON AE encryption fucntion to generate the value of `c0`.  Takes as input a PRNG instance `prng`, the public key `pk` (must be generated by `keygen`), the plaintext `M` (as a bytestring of arbitrary length) and the 16-bytes nonce `nonce` (as a bytestring).
* `decrypt(prng, pk, sk, c, nonce)`:
Implements the decryption function process of POLKA. The practical implementation relies on the ASCON decryption function to produces the decrypted plaintext. Takes as input a PRNG instance `prng`, the public key `pk` and the secret key `sk` (must be generated by `keygen`), the ciphertext `c` (produced by `encrypt`) and nonce `nonce` (must be the same as the one used to generate `c`).

The POLKA scheme requires to sample randomness during the key generation, the encryption and the decryption process. For this purpose, the PRNG class defined in [polka_utils.sage](polka_utils.sage) gives access to functions to generate a random polynomial uniformly over $R_q$ or to sample an error polynomial. While these function can be used directly, the class PRNG also provide top-level functions `randomness_keygen()` and `randomness_enc_dec()` that generate the full randomness for the corresponding steps. The PRNG class also offers the possibility to (re-)seed each of its instances independently. In this setting, **reproducable results can be obtained** by seeding the PRNG instance appropriately and by ensuring that the computation are perfomed on the same data (i.e., same plaintext, ciphertext or nonce)and that the randomness is generated in a similar order (which is ensured when the functions `randomness_keygen()`and `randomness_enc_dec()` are used, check [polka.sage](polka.sage) for more details). 

## Quick Example

The file [example.sage](example.sage) contains a simple run example. Namely, the file shows how to generate a pair of public/secret key, encrypt a plaintext of arbitrary length and decrypt it. The example can be simply executed by running the command

```
sage example.sage
```
which should display the message 
```
Enc-dec ok!
```
NOTE: this requires the files to have been correctly preparsed and the submodule to been correctly initialized beforehand ).

## Known Limitations 

The randomness generation process is based on the Numpy Python package, which makes it quite difficult to use outside a Python environment. Although generating the same random values as our own is not strictly necessary in a practical deployment of POLKA, it may be desired in order to perform regression tests to verify the correct functioning of a new implementation. For this purpose, a PRNG instance using a similar seed can be used to easily generate only the random values used in an execution. These can then be stored and passed as input to the implementation being verified.

This code is given as a reference code, and does not intend to be secure against side-channel attacks. In particular, it does not implement SPA and DPA countermesures (that would require a lower level programming langage) and does not use a secured randomness source. It is also implemented with an unprotected Ascon as authenticated encryption scheme for illustration.

## License

Copyright 2023 UCLouvain

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE
