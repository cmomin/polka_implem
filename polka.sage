### TODO: generate this files per Makefile
# Import stuff
from polka_utils import Params, PRNG, embedding 
from ascon import ascon_hash, ascon_encrypt, ascon_decrypt

from math import ceil, log

def pnorm(pol,cfg):
    '''
    Norm of the polynomial 'pol' for the considered instance
    configuration.
    '''
    if cfg.version=="16":
        return pnorminf(pol,cfg)
    else: 
        raise ValueError("Version not supported")

def pnorminf(pol,cfg):
    '''
    Infinite norm of the polynomial 'pol'.
    '''
    np_cfs = [int(e) for e in list(pol)]
    return max(embedding(np_cfs,cfg.q))

def pol2bytes(pol,cfg):
    '''
    Encoding of the polynomial 'pol' into a bytestring object.

    In practice, the coefficients are encoded sequentially from the term with the smaller
    degree to the higher one. 

    The coefficient are encoded per byte, from the LSB to the MSB.
    
    # TODO develop encoding or add example
    
    '''
    # Compute the amount of bytes required to encode 
    # a coefficient
    t = ceil(log(cfg.q,2**8))
    # Fetch coefficients (normally list(pol) return always n coefficients)
    pc = [int(e) for e in pol]
    # Iterate over all coefficient and decode byte 
    lb = []
    for c in pc:
        for i in range(t):
            lb.append((c>>(8*i)) & 0xff)
    return bytes(lb)

def keygen(prng, version="16"):
    '''
    Generation of the (pk,sk) pair. 

    Takes an isntance of PRNG as input in order to generate 
    the random values 'a', 's' and 'e'.

    Return the pair (pk, sk) with the instance parameter object 
    embedded in pk as the first element of the 'pk' tuple. 
    '''
    # Generate instance params
    cfg = Params(version)
    assert cfg.version == prng.version, 'Version mismatch between PRNG and keygen.'
    # Draw random s,e, compute b, check if inversible
    b_s = cfg.A(0)
    while (b_s.gcd(cfg.A.gen()^cfg.n +1)!=1):
        # Draw a, s, e from PRNG 
        (a_s, s_s, e_s) = prng.randomness_keygen()
        # Compute b
        b_sR = cfg.p * ( (a_s * s_s) + e_s)
        b_s = cfg.A(list(b_sR))
    # Return the pair (pk, sk)
    return ((cfg, a_s, b_sR, b_sR^(-1)), s_s)

def check_norm(p,nv,cfg):
    '''
    Verify if the norm of the polynomial 'p' is less of equal to 'nv'
    '''
    return pnorm(p,cfg)<=nv

def encrypt(prng, pk, M, nonce):
    '''
    Encryption of the POLKA scheme. Uses the ASCON hash/AE encryption function. 

    prng: The PRNG instance to generate the randomness. Instance 
    of the class polka_utils.PRNG
    pk: public key as generated by keygen().
    M: the plaintext, as a bytestring object instance of arbitrary length. 
    nonce: the nonce, as a bytestring object of 16 bytes (as expected by the ASCON
    encryption process). 
    '''
    # Parse data from pk
    (cfg, a, b, _) = pk
    assert cfg.version == prng.version, 'Version mismatch between PRNG and public-key.'
    # Generate errors
    (r, e1, e2) = prng.randomness_enc_dec()

    # Create c1, c2 and K
    c1 = a * r + e1
    c2 = b * r + e2
    
    d2h = pol2bytes(r,cfg) + pol2bytes(e1,cfg) + pol2bytes(e2,cfg)
    K = ascon_hash(d2h)[:16]
    # Create c0
    c0 = ascon_encrypt(K,nonce,bytes([]),M)
    return (c0, c1, c2) 

def decrypt(prng, pk, sk, c, nonce):
    '''
    Decryption of the POLKA scheme. Uses the ASCON AE decryption function.

    prng: The PRNG instance to generate the randomness. Instance 
    of the class polka_utils.PRNG
    pk/sk: public/secret key as generated by keygen().
    c: the ciphertext, as obtained with encrypt(). 
    nonce: the nonce, as a bytestring object of 16 bytes (as expected by the ASCON
    encryption process). 

    Decryption is divided in 5 steps (dec_step_1:5) as described in the Figure 2
    of Section 5 in the paper. 

    '''
    # Parse data
    (cfg, a, b, ib) = pk
    assert cfg.version == prng.version, 'Version mismatch between PRNG and public-key.'
    (c0, c1, c2) = c 
    ## Step 1
    (rp, e1p, e2p, c1p, c2p, c1b, c2b) = dec_step_1(prng, c1, c2, a, b, cfg)
    ## Step 2
    t = dec_step_2(c1b, sk, cfg)
    ## Step 3
    uni = dec_step_3(t, c1b, c2b, a, ib, cfg)
    # Check if an error occured during step 3
    if uni == None: return None
    (rb, e1b, e2b) = uni
    ## Step 4
    K = dec_step_4(rp, e1p, e2p, rb, e1b, e2b, cfg)
    # Check if an error occured during step 4
    if K == None: return None
    ## Step 5
    return dec_step_5(K, nonce, c0)

def dec_step_1(prng, c1, c2, a, b, cfg):
    # Sample dummy
    (rp, e1p, e2p) = prng.randomness_enc_dec()

    # Compute Cps
    c1p = (a * rp) + e1p
    c2p = (b * rp) + e2p

    # Compute Cbs
    c1b = c1 + c1p
    c2b = c2 + c2p

    # Return value
    return (rp, e1p, e2p, c1p, c2p, c1b, c2b)

def dec_step_2(c1b, s, cfg):
    t = (c1b * cfg.p) * s 
    return t

def dec_step_3(t, c1b, c2b, a, bm, cfg):
    ub = c2b - t

    em_q_ub = embedding(ub, cfg.q)
    em_p_q_ub = embedding([e % cfg.p for e in em_q_ub], cfg.p)
    e2b = cfg.R(em_p_q_ub)
    if not(check_norm(e2b,2*cfg.B,cfg)): return None

    rb = (c2b-e2b)*bm
    if not(check_norm(rb,2*cfg.B,cfg)): return None

    e1b = c1b - (a * rb)
    if not(check_norm(e1b,2*cfg.B,cfg)): return None

    return (rb,e1b,e2b)

def dec_step_4(rp, e1p, e2p, rb, e1b, e2b, cfg):
    r = rb - rp
    if not(check_norm(r,cfg.B,cfg)): return None

    e1 = e1b - e1p
    if not(check_norm(e1,cfg.B,cfg)): return None

    e2 = e2b - e2p 
    if not(check_norm(e2,cfg.B,cfg)): return None

    # Format K
    d2h = pol2bytes(r,cfg) + pol2bytes(e1,cfg) + pol2bytes(e2,cfg)
    K = ascon_hash(d2h)[:16]
    return K

def dec_step_5(K, nonce, c0): 
    return ascon_decrypt(K, nonce, bytes([]), c0) 


if __name__ == "__main__":
    # Example of usage
    import numpy as np

    # Example configuration
    lM = 19
    lNonce = 16
    seed_prng = None # Fix a value here to ensure reproducable result

    # Generation of the PRNG instance. 
    prng = PRNG(seed=seed_prng)

    # Key generation
    (pk, sk) = keygen(prng)    

    # Encryption for a random M and nonce
    M = bytes(np.random.randint(0,256,size=lM,dtype=np.uint8).tolist())
    nonce = bytes(np.random.randint(0,256,size=lNonce,dtype=np.uint8).tolist())

    # Encryption
    c = encrypt(prng, pk, M, nonce)

    # Decryption
    Md = decrypt(prng, pk, sk, c, nonce)

    assert Md == M
    print("Enc-dec ok!")

